[toc]

+ 关联式数据库
  mysql
  orable
  postgresql
  sql server
+ 非关联式数据库
  mongoDB
  redis

## SQL通用语法

+ **DDL**
  数据定义语言：用来定义数据库对象：数据库/表/列等。
  CREATE ALTER DROP
+ **DML**
  数据操作语言：对表中记录进行更新。
  INSERT DELETE UPDATE
+ **DCL**
  数据控制语言：定义数据库的访问权限和安全级别，即创建用户。
  GRANT DENY REVOKE
+ **DQL**
  数据库查询语言
  SELECT

## 关系

概念是建立在笛卡尔积概念基础上的。

**满足一定语义的D1 × D2 x ... x Dn 的子集叫做在域D1/D2/.../Dn上的关系。**

### 关系模型

| 概念模型     | 关系模型     |
| ------------ | ------------ |
| 实体         | 关系         |
| 属性         | 属性         |
| 域           | 域           |
| 关键字（码） | 候选键（码） |
| 实体型       | 关系模式     |
| 实体集       | 关系实例     |

### 规范化

+ **第一范式**
  数据库的每一列都是不可分割的基本数据项，下面情况属于可分割情况：

  + 学生（姓名，电话号码）可分割为
  + 学生（姓名，手机号码，座机号码）
+ **第二范式**
  表中必须存在主键，且其他属性必须完全依赖于主键：

  + 学生（学号，姓名，性别）
    学号是每个学生唯一标识
+ **第三范式**
  满足第二范式情况下，所有属性都**不传递依赖于主键**，满足第三范式

  + 学生借书情况（借阅编号，学生学号，书籍编号，书籍名称，书籍作者）
    书籍编号依赖于借阅编号，书籍作者依赖于书籍编号，存在传递依赖情况
  + 学生借书情况（借阅编号，学生学号，书籍编号）
  + 书籍（书籍编号，书籍名称，书籍作者）
+ **BCNF**
  作为第三范式的补充

### tables and keys

`primary key` 设置为主键的key可以唯一区分。

`foreign key` 设置为外键，可以对应别人的表格也可以对应自己的表格。

![1677412714980](image/数据库/1677412714980.png)

## SQL语句--查询

```SQL
CREATE DATABASE `NAME` IF NOT EXISTS `NAME` DEFAULT utf8 COLLATE utf8_general_ci;
//创建数据库(设定编码格式为utf-8)

[CONTRAINT <外键名>] FOREIGN KEY 字段名 [, 字段名二 , ...] REFERENCES <主表名> 主键列1 [, 主键列2 , ... ]
//创建外键

ALTER TABLE `表名` DROP PRIMARY KEY 
//删除主键


DROP DATABASE `NAME`;
//删除数据库

SHOW DATABASE;
//查看已创建的数据库

USE  `database`;
//使用数据库

CREATE TABLE `table`
//创建表格

DESCRIBE `TABLE`;
//查看表格属性

ALTER TABLE  `table` ADD `property` INT;
//为表格添加属性

ALTER TABLE  `table` DROP `property` INT;
//删除表格属性

INSERT INTO `student` VALUES()
//填入资料


更新表记录
UPDATE `TABLE` SET `FIELD = VALUE` 

```

### 条件查询

+ 比较运算符

  | < = > <= >= |                                                              |
  | ----------- | ------------------------------------------------------------ |
  | BETWEEN     | 某一区间的值                                                 |
  | IN(SET)     | 显示在 IN 列表中的值，如：IN(200 , 300)                      |
  | LIKE        | 模糊查询，有两种通配符：%用于匹配多个字符，_用来匹配一个字符 |
  | IS NULL     | 判断是否为空                                                 |
+ 逻辑运算符

  + AND
  + OR
  + NOT

### 排序查询

```sql
SELECT * FROM `TABLE` WHERE `CONDITION` ORDER BY `COLUMN` ASC|DESC 
```

### 分组和分页查询

```sql
SELECT SUM(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件
//使用GROUP BY 对查询结果进行分组，需结合聚合函数，还可添加HAVING 限制分组条件

SELECT * FROM 表名 LIMIT 数量
//通过limit限制查询数量，只取前n 个结果



```

+ HAVING 和 WHERE 区别：
  + HAVING是在分组后对数据进行过滤，后面可以使用分组函数
  + WHERE是在分组前对数据进行过滤，后面不能使用分组函数

查询工资和大于2000 的工资总和大于9000 的部门名称和工资和

```sql
SELECT `department , GROUP_CONCAT(salary).SUM(salary)`
FROM `employee`
WHERE salary > 2000
GROUP BY `department`
HAVING SUM(salary) > 9000
ORDER BY SUM(salary) DESC;
//降序排列
```

![1680596988793](image/数据库/1680596988793.png)

### 多表查询

通过连接转换为单表查询

```sql
SELECT * FROM 表1 , 表2
这样会得到两张表的笛卡尔积            
```

### 自身连接查询

将表本身和表进行笛卡尔积计算，得到结果。
由于表名相同，需要先起一个别名：

```sql
SELECT * FROM 表名 别名1 , 表名 别名2
```

### 外连接查询（用于联合查询）

+ **INNER JOIN** 进行内连接，返回连个表满足条件的交集部分
  ![1680605983212](image/数据库/1680605983212.png)
+ **LEFT JOIN** 进行左连接

### 嵌套查询

```sql
SELECT * FROM 表名 WHERE 列名 = ( SELECT 列名 FROM 表名 WHERE CONDITION)
```

## SQL语句--控制

### 用户授权

```SQL
GRANT ALL|权限1 , 权限2 , ... (列1 , ...) ON 数据库.表|* TO USER [WITH GRANT OPTION]
//WITH GRANT OPTION 被授权的用户能将以获得的授权继续授权给其他用户

REVOKE ALL|权限1 , 权限2 , ... (列1 , ...) ON 
数据库.表|* FROM 用户
```

## 视图

是一个查询结果

```sql
CREATE VIEW 视图名称（列名） as 子查询语句 [WITH CHECK OPTION];
```

WITH CHECK OPTION 指当创建后，若更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入。

## 索引

当数据量特别庞大时，通过创建索引，能够大大提高查询效率，就像Hash表一样，能够快速定位元素存放的位置。

```sql
--创建索引
CREATE IINDEX 索引名 ON 表名 (列名)

--查看表中的索引
SHOW INDEX FROM student
```

## 触发器

在某种条件下自动触发。
触发器用于检查内容的安全性，相比直接添加约束，触发器更加灵活。

```sql
CREATE TRIGGER 触发器名 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON [表名|视图名] FOR EACH ROW FROM student WHERE student.sno = new.sno
## FOR EACH ROW 表示针对每一行都生效
```

## 事务

当要进行很多操作时，如依次删除很多个表的数据，需要执行大量SQL语句完成。这些操作语句可以构成一个事务，

```SQL
SHOW ENGINES;
```

![1680664806403](image/数据库/1680664806403.png)

MYSQL默认采用InnoDB引擎，可以修改为其他引擎。

**事务特性**

+ **原子性(Atomicity)**
  一个transaction中的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节。
  事务执行过程中如果发生错误，就会回滚（rollback）到事务开始前的阶段。
+ **一致性(consistency)**
  在事务开始前或结束后，数据库完整性未被破坏。表示写入的资料必须完全符合所有的预设规则。
+ **隔离性(isolation)**
  数据库允许多个并发事务同时对其数据进行读写和修改的能力。
  隔离级别：

  + 读未提交
  + 读提交
  + 可重复读
  + 串行化
+ **持久性(duration)**
  事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失。

```sql
BEGIN ; # 开始事务
...
ROLLBACK ; # 回滚事务
SAVEPOINT ; # 回滚点/添加回滚点
ROLLBACK TO ; # 回滚点/回滚到指定回滚点
...
COMMIT ; # 提交事务
```

**一旦提交，就无法再回滚！**


## 数据格式

+ 用于字符串存储
  CHAR(n)
  VARCHAR(n)
+ 用于数字存储
  smallint
  int
  bigint
  float
  double
+ 用于存储时间
  date 存储日期
  time 存储时间
  year 存储年份
  datetime 存储混合日期+时间
+ **列级约束条件**
  主键primary key
  外键foreign key
  唯一unique
  检查check（MYSQL不支持）
  默认default
  非空 not null

## 数据库规范化

## INDEX 索引

### classification

+ **from the storage structure**
  B-tree
  Hash
  Full-Index
  R-Tree

**hash**
虽然可以快速定位，但是没有顺序，IO复杂度高。

**二叉树**
树的高度不均匀，不能自平衡，查找效率和数据有关（树的高度），并且IO代价高。

**红黑树**
树的高度随着数据量增加而增加，IO代价高。

+ **from the application level**
  normal index 普通索引
  unique index 唯一索引
  composite index 复合索引
+ **from the logical order relationship between the physical order of data and key values in**:
  clustered index
  non clustered index

**普通索引**
一个索引值只包含单个列，一个表可有多个单列索引

**唯一索引**
索引列的值必须唯一，但允许有空值

**复合索引**
一个索引包含多个列

**聚集索引**
InnoDB 在同一个结构中保存了B-TREE索引

## mysql遇到问题

mysql本地服务器上Mysql 服务启动后停止。某些服务在未由其他服务或程序使用时将自动停止。

此处我只是清除了datadir下面的data，而非mysql安装路径下的data 文件夹中的内容
