[toc]

# 面试
## 常见问题
+ 自我介绍
+ 技术栈
+ 项目承担任务
+ 对数据库是否了解
+ 对xxx的理解
+ 目前是否单身？
+ 职业规划
+ 家庭情况


## 开发人员评测
(micro_frank)
### 素质结构

1.事业心
2.战略观念（你怎么看待arcgis）
3.开拓性
4.协作性
5.进取心
6.坚韧性


### 智力结构
1.基础理论（数据结构）
2.专业知识（项目）
3.观察力（发现bug)
4.判断力（发现bug在哪)

### 能力结构

1.发现问题的能力
2.获信息的能力（分配任务，查找论坛学为己用）
3.创新能力

### 绩效结构
1.技术经济效益（社会经济效益）


## 技术管理人员
### 素质结构
1.法制观念
2.事业心
3.技术经济概念
4.责任心
### 智力结构
1，专业知识
2.知识面（前端后端交互）
3.对新技术新产品敏感性
4.思维力
### 能力结构
1.科学技术鉴别能力
2.灵活性
3.信息沟通能力
4.协调能力
### 绩效结构
1.科学技术的成果
2.社会经济效益

## javascript

浅拷贝是复制一个对象的引用，深拷贝是克隆一个新的对象。与原对象有不同的内存地址。


### js代码规范
+ 驼峰命名
+ 运算符` = + - * / `添加空格
+ 全局变量为大写（UPPERCASE），常量大写。
+ HTML和CSS横杠。
### 为甚么要实现深度克隆？

### 为什么vue中的data要用return 返回

**组件就是一个可复用的vue实例**

及如果data是一个普通的对象，那么所有复用此实例的组件都将引用同一份数据，造成数据污染。

    此时若将data封装成一个函数，在实例化组件的时候知识调用了此函数生成的副本，避免了数据污染。

### 谈谈map和forEach()的区别

### vat let 和变量提升问题

```javascript
function getNum() {
  console.log(num) 
  var num = 1  
}
getNum();
//会输出undefined,因为等价于
//|
//\/
function getNum(){
    var num
    console.log(num)
    var num=1
}
getNum();
```

作用域控制了变量和函数的可见性和生命周期。
**问题**
1.会导致变量被覆盖
2.变量没有被销毁
**解决**：var & let

+ 暂时性死区

```javascript
var tmp=123;
if(true){
  tmp='abc';//referenceError
  let tmp;
}
```

尽管存在全局变量tmp,但在块级作用域内let声明了一个局部变量tmp,在声明之前就使用了，会报错。

### 为什么Object.prototype.toString()能精确进行类型判断？

获取this指向的对象的[[Class]]属性的值。（这是用call改变this指向的原因）

### bind() call() apply()用法区别

![1676019915394](image/工作/1676019915394.png)

### 箭头函数和普通函的区别

1.this指向不同；
2.普通函数，谁调用这个函数,this指向谁；
3.箭头函数，在哪里定义这个函数，this指向谁；

```javascript
var obj={
  name:"xiaoming";
  setTimeout(()=>{
    console.log(this.name);
  }，500)
}
obj.setTimeout();
//输出xiaoming,因为此时箭头函数指向上一级对象

var obj={
  name:'xiaomign';
  setTimeout(function(){
    console.log(this.name);
  }，500)
}
obj.setTimeout();
//输出undefined，因为此时指向setTimeout()方法是全局对象
```

### 谈谈闭包

函数嵌套函数，内部函数就是闭包。
正常情况下，函数执行完成，会释放内存空间。

```javascript
function outerFun(){
  function innerFun(){
  //...此时内部就是闭包
  }
}
```
### DOM树
![1676537736084](image/工作/1676537736084.png)

+ addEventListener()
```javascript
  element.addEventListener(event,function,useCapture);
  //(第一个事件类型，第二个调用函数，第三个布尔值用于描述事件是冒泡还是捕获（可选）)
```
+ appendChild()创建新的HTML元素在尾部
+ insertBefore()创建新元素添加到开始位置
+ removeChild()移除元素（需要知道父元素所在位置）
+ replaceChild()替换HTML元素






### 网址的组成部分 （协议 主机 端口 路径 查询参数 锚点）

`https://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#anchor`
**协议**https://是默认协议
**主机**host是资源所在网站名或服务器名字，又称域名。
**端口**同一域名下可能多个网站，之间通过端口(port)区分。
**路径**资源在网站的位置
**查询参数**parameter是提供给服务器的额外信息。用key-value pair（键值对）形式。
**锚点**anchor内部定义点，



### 函数表达式和函数声明式有什么区别？
```javascript
sayHi('john')

function sayHi(name){
  alert(`hello,${name}`)
}
//函数声明式是在声明之前就可被调用
```

```javascript
sayHi('john')

let sayHi = function(name){
  alert(`hello,${name}`)
}
//函数表达式在声明之前不能调用
`
```



### 深拷贝浅拷贝

+ **浅拷贝**
  当拷贝引用类型时，源对象也会被修改。
+ **深拷贝**
  在内存堆区域重新开辟空间，修改拷贝对象不会影响到源对象。

**浅拷贝方法**：
1.直接赋值

```javascript
var user1={
  name:'法医',
  age:14;
}
var user2=user1;
use2.name='狼人';
console.log(user1);//{name:'狼人',age:14}
```

2.Object.assign()方法
如果拷贝的是基本数据类型，拷贝的就是基本上数据类型的值；如果拷贝的是引用数据类型，拷贝的就是引用内存地址。

### 基本类型和引用类型

**基本类型：undefined/boolean/number/string/nul**
基本类型的值是存放在栈内存中的

**引用类型**
**即对象**
引用类型数据保存在堆内存中，
引用类型的值是按引用访问的。

### 代码空间/堆/栈空间

### new 一个对象时发生了什么？

```javascript
var obj=new Base();
obj.proto=Base.prototype;
Base.call(obj);
//创建一个空对象
//将空对象的_proto_成员指向Base函数对象的prototype成员对象
//Base函数对象的this指针替换为obj,然后调用Base函数
```

### new 和 Object.create()区别

### 类数组对象

**必须具有length属性的对象**

```javascript
let arrayLike={
  0:'tom',
  1:'54',
  2:'男',
  3:['a','b','c'],
  'length':4//必须有此属性，若没有，转换后数组是个空数组
}
let arr=Array.from(arrayLike);
console.log(arr);//['tom','54','男',['a','b','c']]
```

**类数组转为真正数组条件：**
1.必须具有length属性，用于指定数组的长度。
2.属性名必须为数值型或字符串型数字。

### Array()有哪些方法？

**Array.from()**
1.将一个类数组对象或可遍历对象转换为一个真正数组。
![1676252327186](image/工作/1676252327186.png)

### 存取器函数set get

`get`关键字将对象的属性和函数进行绑定，当属性被访问时，对应函数被执行。

```javascript
const obj={
  log:['example','latest'],
  get latest(){
    if(this.log.lenth==0) return undefined;
    return this.log[this.log.length-1];
  }
}
console.log(obj.latest);
//'latest'
```

`set`关键字当改变属性值时，对应函数被执行。

```javascript
const language={
  set current(name){
    this.log.push(name);
  },
  log:[]
}
language.current='en';
language.current='fa';
console.log(language.log);
//['en','fa']
```

### Promise 和 Async/Await区别

都是处理异步请求；
+ Promise
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
.then((response)=>response.json()).
then((json)=>{console.log(json)}).
catch((err)=>console.error(err))
.finally(()=>{
  stopLoadingAnimation()
})
```
+ ecmascript2017中加入async/await
```javascript
async function f(){
  const response=await fetch("https://...");
  const json=await response.json();
  console.log(json);
}
f();
```

## vue


### 组件实例实际上是一个代理对象
### 什么是组合式API和选项式API?
通常与`<script setup>`搭配使用。

包含以下方面API
+ 响应式API：直接创建响应式状态/计算属性/侦听器。
+ 生命周期钩子：onMounted()/onUnmounted()，使能在组件各生命阶段添加逻辑。
+ 依赖注入：如 provide()/inject()。

能够实现逻辑复用

```javascript
<script setup>
  import {ref,onMounted} from 'vue'

  //响应式状态
  const count = ref(0)

  //用来修改状态/触发更新的函数
  function increment(){
    count.value++
  }

  //生命周期钩子
  onMounted(()=>{
    console.log(`this initial count is ${count.value}`)
  })
  </script>
  <template>
    <button @click = "increment">count is :{{count}}
    </button>
```

**可以将同一个逻辑关注点的代码整合在一起。**

+ 选项式API
可以用包含多个选项的对象来描述组件的逻辑，如`data/methods/mounted。`选项定义的属性会暴露在函数内部this上，指向当前的组件实例。


```javascript
<script>
  export default {
    data(){
      return {
        count:0;
      }
    },
    methods:{
      increments(){
        this.count++
      }
    },
    mounted(){
      console.log(`the initial count is ${this.count}`)
    }
  }
  </script>
  <template>
    <button @click="increments">count is :{{count}}
    </button>
  </template>
```

### v-bind v-on v-model区别
v-model是标签外value的双向绑定，v-bind是标签内属性的单向绑定，同时都支持数据的动态变化。

v-bind缩写：
```javascript
<a v-bind:href="url">..</a>

//缩写
<a :href="url">..</a>
```


### 前端路由实现方式？

常见路由实现方式：history&hash

路由工作：通过一定机制，监听用户的行为动作，从而做出对应变化。

+ hash
  浏览器通过 `hashchange`方法，

## es6

### 为什么子类super()一定要放在this之前？




## git 
### zip和ssh区别
ssh可以将历史修改提交记录也clone























## 自我答疑


+ git
  
  目前对git常用指令有所掌握，不过还没有应用到实际团队协作的工作开发中。所以这一方面也是我想在贵公司实践并提升的技能。






















