[toc]

# 面试



## 开发人员评测
(micro_frank)
### 素质结构

1.事业心
2.战略观念（你怎么看待arcgis）
3.开拓性
4.协作性
5.进取心
6.坚韧性


### 智力结构
1.基础理论（数据结构）
2.专业知识（项目）
3.观察力（发现bug)
4.判断力（发现bug在哪)

### 能力结构

1.发现问题的能力
2.获信息的能力（分配任务，查找论坛学为己用）
3.创新能力

### 绩效结构
1.技术经济效益（社会经济效益）


## 技术管理人员
### 素质结构
1.法制观念
2.事业心
3.技术经济概念
4.责任心
### 智力结构
1，专业知识
2.知识面（前端后端交互）
3.对新技术新产品敏感性
4.思维力
### 能力结构
1.科学技术鉴别能力
2.灵活性
3.信息沟通能力
4.协调能力
### 绩效结构
1.科学技术的成果
2.社会经济效益

## javascript

浅拷贝是复制一个对象的引用，深拷贝是克隆一个新的对象。与原对象有不同的内存地址。

### 为甚么要实现深度克隆？

### 为什么vue中的data要用return 返回

**组件就是一个可复用的vue实例**

及如果data是一个普通的对象，那么所有复用此实例的组件都将引用同一份数据，造成数据污染。

    此时若将data封装成一个函数，在实例化组件的时候知识调用了此函数生成的副本，避免了数据污染。

### 谈谈map和forEach()的区别

### vat let 和变量提升问题

```javascript
function getNum() {
  console.log(num) 
  var num = 1  
}
getNum();
//会输出undefined,因为等价于
//|
//\/
function getNum(){
    var num
    console.log(num)
    var num=1
}
getNum();
```

作用域控制了变量和函数的可见性和生命周期。
**问题**
1.会导致变量被覆盖
2.变量没有被销毁
**解决**：var & let

+ 暂时性死区

```javascript
var tmp=123;
if(true){
  tmp='abc';//referenceError
  let tmp;
}
```

尽管存在全局变量tmp,但在块级作用域内let声明了一个局部变量tmp,在声明之前就使用了，会报错。

### 为什么Object.prototype.toString()能精确进行类型判断？

获取this指向的对象的[[Class]]属性的值。（这是用call改变this指向的原因）

### bind() call() apply()用法区别

![1676019915394](image/工作/1676019915394.png)

### 箭头函数和普通函的区别

1.this指向不同；
2.普通函数，谁调用这个函数,this指向谁；
3.箭头函数，在哪里定义这个函数，this指向谁；

```javascript
var obj={
  name:"xiaoming";
  setTimeout(()=>{
    console.log(this.name);
  }，500)
}
obj.setTimeout();
//输出xiaoming,因为此时箭头函数指向上一级对象

var obj={
  name:'xiaomign';
  setTimeout(function(){
    console.log(this.name);
  }，500)
}
obj.setTimeout();
//输出undefined，因为此时指向setTimeout()方法是全局对象
```

### 谈谈闭包

函数嵌套函数，内部函数就是闭包。
正常情况下，函数执行完成，会释放内存空间。

```javascript
function outerFun(){
  function innerFun(){
  //...此时内部就是闭包
  }
}
```

### 网址的组成部分 （协议 主机 端口 路径 查询参数 锚点）

`https://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#anchor`
**协议**https://是默认协议
**主机**host是资源所在网站名或服务器名字，又称域名。
**端口**同一域名下可能多个网站，之间通过端口(port)区分。
**路径**资源在网站的位置
**查询参数**parameter是提供给服务器的额外信息。用key-value pair（键值对）形式。
**锚点**anchor内部定义点，

### 深拷贝浅拷贝

+ **浅拷贝**
  当拷贝引用类型时，源对象也会被修改。
+ **深拷贝**
  在内存堆区域重新开辟空间，修改拷贝对象不会影响到源对象。

**浅拷贝方法**：
1.直接赋值

```javascript
var user1={
  name:'法医',
  age:14;
}
var user2=user1;
use2.name='狼人';
console.log(user1);//{name:'狼人',age:14}
```

2.Object.assign()方法
如果拷贝的是基本数据类型，拷贝的就是基本上数据类型的值；如果拷贝的是引用数据类型，拷贝的就是引用内存地址。

### 基本类型和引用类型

**基本类型：undefined/boolean/number/string/nul**
基本类型的值是存放在栈内存中的

**引用类型**
**即对象**
引用类型数据保存在堆内存中，
引用类型的值是按引用访问的。

### 代码空间/堆/栈空间

### new 一个对象时发生了什么？

```javascript
var obj=new Base();
obj.proto=Base.prototype;
Base.call(obj);
//创建一个空对象
//将空对象的_proto_成员指向Base函数对象的prototype成员对象
//Base函数对象的this指针替换为obj,然后调用Base函数
```

### new 和 Object.create()区别

### 类数组对象

**必须具有length属性的对象**

```javascript
let arrayLike={
  0:'tom',
  1:'54',
  2:'男',
  3:['a','b','c'],
  'length':4//必须有此属性，若没有，转换后数组是个空数组
}
let arr=Array.from(arrayLike);
console.log(arr);//['tom','54','男',['a','b','c']]
```

**类数组转为真正数组条件：**
1.必须具有length属性，用于指定数组的长度。
2.属性名必须为数值型或字符串型数字。

### Array()有哪些方法？

**Array.from()**
1.将一个类数组对象或可遍历对象转换为一个真正数组。
![1676252327186](image/工作/1676252327186.png)

### 存取器函数set get

`get`关键字将对象的属性和函数进行绑定，当属性被访问时，对应函数被执行。

```javascript
const obj={
  log:['example','latest'],
  get latest(){
    if(this.log.lenth==0) return undefined;
    return this.log[this.log.length-1];
  }
}
console.log(obj.latest);
//'latest'
```

`set`关键字当改变属性值时，对应函数被执行。

```javascript
const language={
  set current(name){
    this.log.push(name);
  },
  log:[]
}
language.current='en';
language.current='fa';
console.log(language.log);
//['en','fa']
```

### Promise 和 Async/Await区别

都是处理异步请求；
+ Promise
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
.then((response)=>response.json()).
then((json)=>{console.log(json)}).
catch((err)=>console.error(err))
.finally(()=>{
  stopLoadingAnimation()
})
```
+ ecmascript2017中加入async/await
```javascript
async function f(){
  const response=await fetch("https://...");
  const json=await response.json();
  console.log(json);
}
f();
```

## vue

### 前端路由实现方式？

常见路由实现方式：history&hash

路由工作：通过一定机制，监听用户的行为动作，从而做出对应变化。

+ hash
  浏览器通过 `hashchange`方法，

## es6

### 为什么子类super()一定要放在this之前？
